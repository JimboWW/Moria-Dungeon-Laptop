<!-- ----------------------------------------------------------------------------

Bug List for index1-00.txt

1. Fix when fighting mosnsters so don't they disappear and reappear.
2. Fix monsters being too easy to kill.
3. Fix by creating a way to spend gold.
4. Create way to create persistence in game (save game).
5. Fix death so it is permanent and player has to start over after death. Also, 
   create a graveyard for characters that have died(leaderboard).
6. Fix, sometimes after dungeon floor 1, one row in map is messed up with extra
   spaces between # symbols.
7. Fix that it is too easy to avoid monsters and descend.

 --------------------------------------------------------------------------- -->

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Moria Dungeon</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background-color: #000;
            color: #0f0;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1;
        }

        .game-container {
            display: flex;
            gap: 20px;
        }

        .dungeon {
            background-color: #111;
            border: 2px solid #333;
            padding: 10px;
            font-size: 12px;
            line-height: 1;
            letter-spacing: 0;
        }

        .dungeon-row {
            white-space: pre;
            margin: 0;
            padding: 0;
        }

        .sidebar {
            min-width: 300px;
            background-color: #111;
            border: 2px solid #333;
            padding: 15px;
        }

        .stat-block {
            margin-bottom: 15px;
            border-bottom: 1px solid #333;
            padding-bottom: 10px;
        }

        .controls {
            margin-top: 15px;
            font-size: 12px;
            color: #888;
        }

        .message-log {
            height: 150px;
            overflow-y: auto;
            background-color: #000;
            border: 1px solid #333;
            padding: 5px;
            margin-top: 10px;
            font-size: 11px;
        }

        .message {
            margin-bottom: 2px;
        }

        /* Game element colors */
        .player { color: #ff0; }
        .wall { color: #666; }
        .floor { color: #333; }
        .monster { color: #f00; }
        .treasure { color: #fa0; }
        .stairs { color: #0af; }

        h1 {
            color: #0f0;
            text-align: center;
            margin-bottom: 20px;
            text-shadow: 0 0 10px #0f0;
        }
    </style>
</head>
<body>
    <h1>MORIA DUNGEON</h1>
    
    <div class="game-container">
        <div class="dungeon" id="dungeon"></div>
        
        <div class="sidebar">
            <div class="stat-block">
                <h3>Character Stats</h3>
                <div>Name: <span id="player-name">Adventurer</span></div>
                <div>Level: <span id="player-level">1</span></div>
                <div>HP: <span id="player-hp">20</span>/<span id="player-max-hp">20</span></div>
                <div>XP: <span id="player-xp">0</span></div>
                <div>Gold: <span id="player-gold">0</span></div>
                <div>Depth: <span id="dungeon-depth">1</span></div>
            </div>
            
            <div class="stat-block">
                <h3>Equipment</h3>
                <div>Weapon: <span id="weapon">Dagger</span></div>
                <div>Armor: <span id="armor">Cloth</span></div>
            </div>
            
            <div class="stat-block">
                <h3>Inventory</h3>
                <div id="inventory">Empty</div>
            </div>
            
            <div class="controls">
                <h3>Controls</h3>
                <div>Move: Arrow Keys or WASD</div>
                <div>Attack: Move into enemy</div>
                <div>Stairs: > (down) < (up)</div>
                <div>Rest: R (restore HP)</div>
                <div>Inventory: I</div>
            </div>
            
            <div class="message-log" id="message-log">
                <div class="message">Welcome to the depths of Moria...</div>
                <div class="message">Find the stairs to descend deeper!</div>
            </div>
        </div>
    </div>
    <script>
        // Game configuration constants
        const CONFIG = {
        DUNGEON_WIDTH: 80,
        DUNGEON_HEIGHT: 24,
        
        // Symbols used in the game
        SYMBOLS: {
            player: '@',
            wall: '#',
            floor: '.',
            monster: 'M',
            treasure: '$',
            stairsDown: '>',
            stairsUp: '<',
            empty: ' '
        },
        
        // Monster types with stats
        MONSTER_TYPES: [
            { name: 'Goblin', symbol: 'g', hp: 8, damage: 2, xp: 10 },
            { name: 'Orc', symbol: 'o', hp: 12, damage: 3, xp: 15 },
            { name: 'Troll', symbol: 'T', hp: 20, damage: 5, xp: 25 },
            { name: 'Dragon', symbol: 'D', hp: 50, damage: 10, xp: 100 }
        ],
        
        // Generation parameters
        GENERATION: {
            ROOMS_PER_LEVEL: 8,
            MIN_ROOM_WIDTH: 4,
            MAX_ROOM_WIDTH: 12,
            MIN_ROOM_HEIGHT: 3,
            MAX_ROOM_HEIGHT: 9,
            MIN_MONSTERS: 3,
            MAX_MONSTERS: 11,
            MIN_TREASURES: 2,
            MAX_TREASURES: 7
        },
        
        // Player stats
        PLAYER_DEFAULTS: {
            hp: 20,
            maxHp: 20,
            level: 1,
            xp: 0,
            gold: 0,
            weapon: 'Dagger',
            armor: 'Cloth'
        }
    };
        // Game state management
        const GameState = {
            // Current game state
            state: {
                player: {
                    x: 0, 
                    y: 0, 
                    hp: CONFIG.PLAYER_DEFAULTS.hp, 
                    maxHp: CONFIG.PLAYER_DEFAULTS.maxHp, 
                    level: CONFIG.PLAYER_DEFAULTS.level, 
                    xp: CONFIG.PLAYER_DEFAULTS.xp, 
                    gold: CONFIG.PLAYER_DEFAULTS.gold,
                    weapon: CONFIG.PLAYER_DEFAULTS.weapon, 
                    armor: CONFIG.PLAYER_DEFAULTS.armor
                },
                dungeon: [],
                monsters: [],
                treasures: [],
                stairs: { down: null, up: null },
                depth: 1,
                messages: []
            },
            
            // Get current state
            get() {
                return this.state;
            },
            
            // Reset game state
            reset() {
                this.state = {
                    player: {
                        x: 0, 
                        y: 0, 
                        hp: CONFIG.PLAYER_DEFAULTS.hp, 
                        maxHp: CONFIG.PLAYER_DEFAULTS.maxHp, 
                        level: CONFIG.PLAYER_DEFAULTS.level, 
                        xp: CONFIG.PLAYER_DEFAULTS.xp, 
                        gold: CONFIG.PLAYER_DEFAULTS.gold,
                        weapon: CONFIG.PLAYER_DEFAULTS.weapon, 
                        armor: CONFIG.PLAYER_DEFAULTS.armor
                    },
                    dungeon: [],
                    monsters: [],
                    treasures: [],
                    stairs: { down: null, up: null },
                    depth: 1,
                    messages: []
                };
            },
            
            // Add message to log
            addMessage(message) {
                this.state.messages.push(message);
                if (this.state.messages.length > 100) {
                    this.state.messages.shift();
                }
            },
            
            // Player methods
            getPlayer() {
                return this.state.player;
            },
            
            setPlayerPosition(x, y) {
                this.state.player.x = x;
                this.state.player.y = y;
            },
            
            // Dungeon methods
            getDungeon() {
                return this.state.dungeon;
            },
            
            setDungeon(dungeon) {
                this.state.dungeon = dungeon;
            },
            
            getTileAt(x, y) {
                if (x < 0 || x >= CONFIG.DUNGEON_WIDTH || y < 0 || y >= CONFIG.DUNGEON_HEIGHT) {
                    return CONFIG.SYMBOLS.wall;
                }
                return this.state.dungeon[y][x];
            },
            
            // Monster methods
            getMonsters() {
                return this.state.monsters;
            },
            
            setMonsters(monsters) {
                this.state.monsters = monsters;
            },
            
            getMonsterAt(x, y) {
                return this.state.monsters.find(m => m.x === x && m.y === y);
            },
            
            removeMonster(monster) {
                const index = this.state.monsters.indexOf(monster);
                if (index > -1) {
                    this.state.monsters.splice(index, 1);
                }
            },
            
            // Treasure methods
            getTreasures() {
                return this.state.treasures;
            },
            
            setTreasures(treasures) {
                this.state.treasures = treasures;
            },
            
            getTreasureAt(x, y) {
                return this.state.treasures.find(t => t.x === x && t.y === y);
            },
            
            removeTreasure(treasure) {
                const index = this.state.treasures.indexOf(treasure);
                if (index > -1) {
                    this.state.treasures.splice(index, 1);
                }
            },
            
            // Stairs methods
            getStairs() {
                return this.state.stairs;
            },
            
            setStairs(stairs) {
                this.state.stairs = stairs;
            },
            
            // Depth methods
            getDepth() {
                return this.state.depth;
            },
            
            incrementDepth() {
                this.state.depth++;
            },
            
            // Messages
            getMessages() {
                return this.state.messages;
            }
        };
        // Utility functions
        const Utils = {
            // Random number between min and max (inclusive)
            randomInt(min, max) {
                return Math.floor(Math.random() * (max - min + 1)) + min;
            },
            
            // Random element from array
            randomElement(array) {
                return array[Math.floor(Math.random() * array.length)];
            },
            
            // Check if two rectangles overlap
            rectanglesOverlap(rect1, rect2, buffer = 1) {
                return rect1.x < rect2.x + rect2.width + buffer && 
                    rect1.x + rect1.width + buffer > rect2.x &&
                    rect1.y < rect2.y + rect2.height + buffer && 
                    rect1.y + rect1.height + buffer > rect2.y;
            },
            
            // Get empty floor tiles (not occupied by player, monsters, treasures, or stairs)
            getEmptyFloorTiles() {
                const tiles = [];
                const gameState = GameState.get();
                
                for (let y = 0; y < CONFIG.DUNGEON_HEIGHT; y++) {
                    for (let x = 0; x < CONFIG.DUNGEON_WIDTH; x++) {
                        if (gameState.dungeon[y][x] === CONFIG.SYMBOLS.floor &&
                            !(x === gameState.player.x && y === gameState.player.y) &&
                            !gameState.monsters.some(m => m.x === x && m.y === y) &&
                            !gameState.treasures.some(t => t.x === x && t.y === y) &&
                            !(gameState.stairs.down && gameState.stairs.down.x === x && gameState.stairs.down.y === y) &&
                            !(gameState.stairs.up && gameState.stairs.up.x === x && gameState.stairs.up.y === y)) {
                            tiles.push({ x, y });
                        }
                    }
                }
                return tiles;
            },
            
            // Get all floor tiles
            getAllFloorTiles() {
                const tiles = [];
                const gameState = GameState.get();
                
                for (let y = 0; y < CONFIG.DUNGEON_HEIGHT; y++) {
                    for (let x = 0; x < CONFIG.DUNGEON_WIDTH; x++) {
                        if (gameState.dungeon[y][x] === CONFIG.SYMBOLS.floor) {
                            tiles.push({ x, y });
                        }
                    }
                }
                return tiles;
            },
            
            // Calculate Manhattan distance between two points
            manhattanDistance(x1, y1, x2, y2) {
                return Math.abs(x1 - x2) + Math.abs(y1 - y2);
            },
            
            // Check if position is valid (within bounds and not a wall)
            isValidPosition(x, y) {
                if (x < 0 || x >= CONFIG.DUNGEON_WIDTH || y < 0 || y >= CONFIG.DUNGEON_HEIGHT) {
                    return false;
                }
                return GameState.getTileAt(x, y) === CONFIG.SYMBOLS.floor;
            },
            
            // Check if position is occupied by another entity
            isPositionOccupied(x, y, excludePlayer = false) {
                const gameState = GameState.get();
                
                if (!excludePlayer && x === gameState.player.x && y === gameState.player.y) {
                    return true;
                }
                
                if (gameState.monsters.some(m => m.x === x && m.y === y)) {
                    return true;
                }
                
                return false;
            }
        };
        // User Interface management
        const UI = {
            // Update the entire display
            updateDisplay() {
                this.updateDungeon();
                this.updateStats();
                this.updateMessages();
            },
            
            // Update the dungeon view
            updateDungeon() {
                const dungeonElement = document.getElementById('dungeon');
                const gameState = GameState.get();
                let html = '';
                
                for (let y = 0; y < CONFIG.DUNGEON_HEIGHT; y++) {
                    let row = '';
                    for (let x = 0; x < CONFIG.DUNGEON_WIDTH; x++) {
                        let symbol = gameState.dungeon[y][x];
                        let cssClass = '';
                        
                        // Check for entities at this position
                        if (x === gameState.player.x && y === gameState.player.y) {
                            symbol = CONFIG.SYMBOLS.player;
                            cssClass = 'player';
                        } else if (gameState.stairs.down && x === gameState.stairs.down.x && y === gameState.stairs.down.y) {
                            symbol = CONFIG.SYMBOLS.stairsDown;
                            cssClass = 'stairs';
                        } else if (gameState.stairs.up && x === gameState.stairs.up.x && y === gameState.stairs.up.y) {
                            symbol = CONFIG.SYMBOLS.stairsUp;
                            cssClass = 'stairs';
                        } else {
                            const monster = gameState.monsters.find(m => m.x === x && m.y === y);
                            if (monster) {
                                symbol = monster.symbol;
                                cssClass = 'monster';
                            } else {
                                const treasure = gameState.treasures.find(t => t.x === x && t.y === y);
                                if (treasure) {
                                    symbol = CONFIG.SYMBOLS.treasure;
                                    cssClass = 'treasure';
                                } else if (symbol === CONFIG.SYMBOLS.wall) {
                                    cssClass = 'wall';
                                } else if (symbol === CONFIG.SYMBOLS.floor) {
                                    cssClass = 'floor';
                                }
                            }
                        }
                        
                        if (cssClass) {
                            row += `<span class="${cssClass}">${symbol}</span>`;
                        } else {
                            row += symbol;
                        }
                    }
                    html += '<div class="dungeon-row">' + row + '</div>';
                }
                
                dungeonElement.innerHTML = html;
            },
            
            // Update character stats display
            updateStats() {
                const player = GameState.getPlayer();
                const depth = GameState.getDepth();
                
                document.getElementById('player-level').textContent = player.level;
                document.getElementById('player-hp').textContent = player.hp;
                document.getElementById('player-max-hp').textContent = player.maxHp;
                document.getElementById('player-xp').textContent = player.xp;
                document.getElementById('player-gold').textContent = player.gold;
                document.getElementById('dungeon-depth').textContent = depth;
                document.getElementById('weapon').textContent = player.weapon;
                document.getElementById('armor').textContent = player.armor;
            },
            
            // Update message log
            updateMessages() {
                const logElement = document.getElementById('message-log');
                const messages = GameState.getMessages();
                
                logElement.innerHTML = messages.map(msg => 
                    `<div class="message">${msg}</div>`
                ).join('');
                logElement.scrollTop = logElement.scrollHeight;
            },
            
            // Add a message to the log
            addMessage(message) {
                GameState.addMessage(message);
                this.updateMessages();
            }
        };             
        // Dungeon generation system
        const Dungeon = {
            // Generate a new dungeon level
            generate() {
                this.createEmptyDungeon();
                const rooms = this.generateRooms();
                this.connectRooms(rooms);
                this.placeStairs();
                this.placeMonsters();
                this.placeTreasures();
            },
            
            // Create empty dungeon filled with walls
            createEmptyDungeon() {
                const dungeon = Array(CONFIG.DUNGEON_HEIGHT).fill().map(() => 
                    Array(CONFIG.DUNGEON_WIDTH).fill(CONFIG.SYMBOLS.wall)
                );
                GameState.setDungeon(dungeon);
            },
            
            // Generate rooms using simple algorithm
            generateRooms() {
                const rooms = [];
                const maxAttempts = CONFIG.GENERATION.ROOMS_PER_LEVEL * 3;
                
                for (let attempt = 0; attempt < maxAttempts && rooms.length < CONFIG.GENERATION.ROOMS_PER_LEVEL; attempt++) {
                    const room = this.createRandomRoom();
                    if (room && !this.roomOverlapsExisting(room, rooms)) {
                        rooms.push(room);
                        this.carveRoom(room);
                    }
                }
                
                return rooms;
            },
            
            // Create a random room
            createRandomRoom() {
                const width = Utils.randomInt(CONFIG.GENERATION.MIN_ROOM_WIDTH, CONFIG.GENERATION.MAX_ROOM_WIDTH);
                const height = Utils.randomInt(CONFIG.GENERATION.MIN_ROOM_HEIGHT, CONFIG.GENERATION.MAX_ROOM_HEIGHT);
                const x = Utils.randomInt(1, CONFIG.DUNGEON_WIDTH - width - 2);
                const y = Utils.randomInt(1, CONFIG.DUNGEON_HEIGHT - height - 2);
                
                return { x, y, width, height };
            },
            
            // Check if room overlaps with existing rooms
            roomOverlapsExisting(room, existingRooms) {
                return existingRooms.some(existingRoom => 
                    Utils.rectanglesOverlap(room, existingRoom)
                );
            },
            
            // Carve out a room (turn walls into floors)
            carveRoom(room) {
                const dungeon = GameState.getDungeon();
                for (let y = room.y; y < room.y + room.height; y++) {
                    for (let x = room.x; x < room.x + room.width; x++) {
                        dungeon[y][x] = CONFIG.SYMBOLS.floor;
                    }
                }
            },
            
            // Connect rooms with corridors
            connectRooms(rooms) {
                for (let i = 1; i < rooms.length; i++) {
                    this.createCorridor(rooms[i-1], rooms[i]);
                }
            },
            
            // Create corridor between two rooms
            createCorridor(room1, room2) {
                const x1 = Math.floor(room1.x + room1.width / 2);
                const y1 = Math.floor(room1.y + room1.height / 2);
                const x2 = Math.floor(room2.x + room2.width / 2);
                const y2 = Math.floor(room2.y + room2.height / 2);
                
                // Horizontal corridor
                const startX = Math.min(x1, x2);
                const endX = Math.max(x1, x2);
                this.carveLine(startX, y1, endX, y1, true);
                
                // Vertical corridor
                const startY = Math.min(y1, y2);
                const endY = Math.max(y1, y2);
                this.carveLine(x2, startY, x2, endY, false);
            },
            
            // Carve a line (corridor)
            carveLine(x1, y1, x2, y2, horizontal) {
                const dungeon = GameState.getDungeon();
                
                if (horizontal) {
                    for (let x = x1; x <= x2; x++) {
                        if (y1 >= 0 && y1 < CONFIG.DUNGEON_HEIGHT && x >= 0 && x < CONFIG.DUNGEON_WIDTH) {
                            dungeon[y1][x] = CONFIG.SYMBOLS.floor;
                        }
                    }
                } else {
                    for (let y = y1; y <= y2; y++) {
                        if (y >= 0 && y < CONFIG.DUNGEON_HEIGHT && x1 >= 0 && x1 < CONFIG.DUNGEON_WIDTH) {
                            dungeon[y][x1] = CONFIG.SYMBOLS.floor;
                        }
                    }
                }
            },
            
            // Place stairs
            placeStairs() {
                const emptyTiles = Utils.getEmptyFloorTiles();
                const stairs = { down: null, up: null };
                
                if (emptyTiles.length >= 2) {
                    // Place down stairs
                    const downPos = Utils.randomElement(emptyTiles);
                    stairs.down = downPos;
                    
                    // Place up stairs (if not on first level)
                    if (GameState.getDepth() > 1) {
                        const upPos = Utils.randomElement(emptyTiles.filter(tile => 
                            tile.x !== downPos.x || tile.y !== downPos.y
                        ));
                        stairs.up = upPos;
                    }
                }
                
                GameState.setStairs(stairs);
            },
            
            // Place monsters
            placeMonsters() {
                const emptyTiles = Utils.getEmptyFloorTiles();
                const monsters = [];
                const numMonsters = Utils.randomInt(
                    CONFIG.GENERATION.MIN_MONSTERS, 
                    CONFIG.GENERATION.MAX_MONSTERS
                );
                
                for (let i = 0; i < numMonsters && emptyTiles.length > 0; i++) {
                    const pos = emptyTiles.splice(Utils.randomInt(0, emptyTiles.length - 1), 1)[0];
                    const type = Utils.randomElement(CONFIG.MONSTER_TYPES);
                    
                    monsters.push({
                        x: pos.x, 
                        y: pos.y,
                        name: type.name,
                        symbol: type.symbol,
                        hp: type.hp,
                        maxHp: type.hp,
                        damage: type.damage,
                        xp: type.xp
                    });
                }
                
                GameState.setMonsters(monsters);
            },
            
            // Place treasures
            placeTreasures() {
                const emptyTiles = Utils.getEmptyFloorTiles();
                const treasures = [];
                const numTreasures = Utils.randomInt(
                    CONFIG.GENERATION.MIN_TREASURES, 
                    CONFIG.GENERATION.MAX_TREASURES
                );
                
                for (let i = 0; i < numTreasures && emptyTiles.length > 0; i++) {
                    const pos = emptyTiles.splice(Utils.randomInt(0, emptyTiles.length - 1), 1)[0];
                    const gold = Utils.randomInt(10, 60);
                    
                    treasures.push({
                        x: pos.x, 
                        y: pos.y,
                        gold: gold
                    });
                }
                
                GameState.setTreasures(treasures);
            }
        };                    
        // Player management system
        const Player = {
            // Initialize player position
            initialize() {
                const floorTiles = Utils.getAllFloorTiles();
                if (floorTiles.length > 0) {
                    const pos = Utils.randomElement(floorTiles);
                    GameState.setPlayerPosition(pos.x, pos.y);
                }
            },
            
            // Attempt to move player
            move(dx, dy) {
                const player = GameState.getPlayer();
                const newX = player.x + dx;
                const newY = player.y + dy;
                
                // Check boundaries
                if (newX < 0 || newX >= CONFIG.DUNGEON_WIDTH || newY < 0 || newY >= CONFIG.DUNGEON_HEIGHT) {
                    return false;
                }
                
                // Check for walls
                if (GameState.getTileAt(newX, newY) === CONFIG.SYMBOLS.wall) {
                    UI.addMessage("You bump into a wall.");
                    return false;
                }
                
                // Check for monsters - attack instead of moving
                const monster = GameState.getMonsterAt(newX, newY);
                if (monster) {
                    this.attackMonster(monster);
                    return true; // Turn consumed by combat
                }
                
                // Move player
                GameState.setPlayerPosition(newX, newY);
                
                // Check for treasures
                const treasure = GameState.getTreasureAt(newX, newY);
                if (treasure) {
                    player.gold += treasure.gold;
                    GameState.removeTreasure(treasure);
                    UI.addMessage(`You found ${treasure.gold} gold!`);
                }
                
                // Check for stairs
                const stairs = GameState.getStairs();
                if (stairs.down && newX === stairs.down.x && newY === stairs.down.y) {
                    UI.addMessage("You see stairs leading down. Press > to descend.");
                }
                if (stairs.up && newX === stairs.up.x && newY === stairs.up.y) {
                    UI.addMessage("You see stairs leading up. Press < to ascend.");
                }
                
                return true;
            },
            
            // Attack a monster
            attackMonster(monster) {
                const damage = Utils.randomInt(1, 6) + 3; // Simple damage calculation
                monster.hp -= damage;
                UI.addMessage(`You attack the ${monster.name} for ${damage} damage!`);
                
                if (monster.hp <= 0) {
                    UI.addMessage(`The ${monster.name} dies!`);
                    const player = GameState.getPlayer();
                    player.xp += monster.xp;
                    
                    // Remove the monster
                    GameState.removeMonster(monster);
                    
                    // Level up check
                    this.checkLevelUp();
                } else {
                    // Monster attacks back
                    const monsterDamage = Utils.randomInt(1, monster.damage) + 1;
                    const player = GameState.getPlayer();
                    player.hp -= monsterDamage;
                    UI.addMessage(`The ${monster.name} attacks you for ${monsterDamage} damage!`);
                    
                    if (player.hp <= 0) {
                        this.gameOver();
                    }
                }
            },

            // Check if player should level up
            checkLevelUp() {
                const player = GameState.getPlayer();
                const xpNeeded = player.level * 100;
                
                if (player.xp >= xpNeeded && player.level < 200) {
                    player.level++;
                    player.maxHp += 5;
                    player.hp = player.maxHp; // Full heal on level up
                    UI.addMessage(`Level up! You are now level ${player.level}!`);
                    
                    if (player.level === 200) {
                        UI.addMessage("You have reached the maximum level!");
                    }
                }
            },
            // Rest to recover health
            rest() {
                const player = GameState.getPlayer();
                
                if (player.hp < player.maxHp) {
                    player.hp = Math.min(player.maxHp, player.hp + 3);
                    UI.addMessage("You rest and recover some health.");
                    return true; // Turn consumed
                } else {
                    UI.addMessage("You are already at full health.");
                    return false; // No turn consumed
                }
            },

            // Go down stairs
            goDownstairs() {
                const player = GameState.getPlayer();
                const stairs = GameState.getStairs();
                
                if (stairs.down && player.x === stairs.down.x && player.y === stairs.down.y) {
                    if (GameState.getDepth() >= 40) {
                        UI.addMessage("You have reached the deepest depths of Moria! You cannot go any deeper.");
                        return false;
                    }
                    
                    GameState.incrementDepth();
                    UI.addMessage(`You descend to level ${GameState.getDepth()}.`);
                    
                    if (GameState.getDepth() === 40) {
                        UI.addMessage("You have reached the final floor of the dungeon!");
                    }
                    
                    // Generate new level
                    Dungeon.generate();
                    this.initialize();
                    
                    return true;
                } else {
                    UI.addMessage("There are no stairs here.");
                    return false;
                }
            },

            // Go up stairs
            goUpstairs() {
                const player = GameState.getPlayer();
                const stairs = GameState.getStairs();
                
                if (stairs.up && player.x === stairs.up.x && player.y === stairs.up.y) {
                    if (GameState.getDepth() > 1) {
                        GameState.state.depth--;
                        UI.addMessage(`You ascend to level ${GameState.getDepth()}.`);
                        
                        // Generate new level
                        Dungeon.generate();
                        this.initialize();
                        
                        return true;
                    } else {
                        UI.addMessage("You escape the dungeon! Victory!");
                        return false;
                    }
                } else {
                    UI.addMessage("There are no stairs here.");
                    return false;
                }
            },
            
            // Game over
            gameOver() {
                UI.addMessage("You have died! Game Over.");
                UI.addMessage("Refresh the page to start again.");
            }
        };       
        // Monster AI and management system
        const Monsters = {
            // Move all monsters (called after player turn)
            moveAll() {
                const monsters = GameState.getMonsters();
                const player = GameState.getPlayer();
                
                monsters.forEach(monster => {
                    this.moveMonster(monster, player);
                });
            },
            
            // Move a single monster with simple AI
            moveMonster(monster, player) {
                // Calculate distance to player
                const dx = player.x - monster.x;
                const dy = player.y - monster.y;
                const distance = Utils.manhattanDistance(monster.x, monster.y, player.x, player.y);
                
                // Only move if player is within range and randomly decide to move
                if (distance <= 3 && Math.random() < 0.6) {
                    let moveX = 0, moveY = 0;
                    
                    // Choose direction to move (prioritize the larger distance)
                    if (Math.abs(dx) > Math.abs(dy)) {
                        moveX = dx > 0 ? 1 : -1;
                    } else if (Math.abs(dy) > 0) {
                        moveY = dy > 0 ? 1 : -1;
                    }
                    
                    const newX = monster.x + moveX;
                    const newY = monster.y + moveY;
                    
                    // Check if move is valid
                    if (this.canMoveTo(monster, newX, newY)) {
                        monster.x = newX;
                        monster.y = newY;
                    }
                }
            },
            
            // Check if monster can move to a position
            canMoveTo(monster, x, y) {
                // Check bounds
                if (x < 0 || x >= CONFIG.DUNGEON_WIDTH || y < 0 || y >= CONFIG.DUNGEON_HEIGHT) {
                    return false;
                }
                
                // Check for walls
                if (GameState.getTileAt(x, y) === CONFIG.SYMBOLS.wall) {
                    return false;
                }
                
                // Check for player (monsters can't move into player)
                const player = GameState.getPlayer();
                if (x === player.x && y === player.y) {
                    return false;
                }
                
                // Check for other monsters
                const monsters = GameState.getMonsters();
                if (monsters.some(m => m !== monster && m.x === x && m.y === y)) {
                    return false;
                }
                
                return true;
            },
            
            // Get monster at specific position
            getAt(x, y) {
                return GameState.getMonsterAt(x, y);
            },
            
            // Remove a monster from the game
            remove(monster) {
                GameState.removeMonster(monster);
            }
        };               
        // Input handling and main game controller
        const Input = {
            // Initialize input handling
            init() {
                document.addEventListener('keydown', (event) => {
                    this.handleKeyPress(event);
                });
            },
            
            // Handle keyboard input
            handleKeyPress(event) {
                let turnTaken = false;
                
                switch(event.key.toLowerCase()) {
                    case 'arrowup':
                    case 'w':
                        event.preventDefault();
                        turnTaken = Player.move(0, -1);
                        break;
                        
                    case 'arrowdown':
                    case 's':
                        event.preventDefault();
                        turnTaken = Player.move(0, 1);
                        break;
                        
                    case 'arrowleft':
                    case 'a':
                        event.preventDefault();
                        turnTaken = Player.move(-1, 0);
                        break;
                        
                    case 'arrowright':
                    case 'd':
                        event.preventDefault();
                        turnTaken = Player.move(1, 0);
                        break;
                        
                    case 'r':
                        turnTaken = Player.rest();
                        break;
                        
                    case '.':
                    case '>':
                        turnTaken = Player.goDownstairs();
                        break;
                        
                    case '<':
                        turnTaken = Player.goUpstairs();
                        break;
                        
                    case 'i':
                        // TODO: Implement inventory
                        UI.addMessage("Inventory system not yet implemented.");
                        break;
                }
                
                // If player took a turn, update game state
                if (turnTaken) {
                    this.processTurn();
                }
            },
            
            // Process a complete game turn
            processTurn() {
                // Move monsters
                Monsters.moveAll();
                
                // Update display
                UI.updateDisplay();
            }
        };
        // Main game controller
        const Game = {
            // Initialize the entire game
            init() {
                // Reset game state
                GameState.reset();
                
                // Generate initial dungeon
                Dungeon.generate();
                
                // Place player
                Player.initialize();
                
                // Initialize input handling
                Input.init();
                
                // Initial display update
                UI.updateDisplay();
                
                // Welcome message
                UI.addMessage("You enter the dark depths of Moria...");
                UI.addMessage("Find the stairs to descend deeper!");
            },
            
            // Reset and restart the game
            restart() {
                this.init();
            }
        };
        // Initialize and start the game
        Game.init();
    </script>
</body>
</html>